{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/canvas/index.js","webpack:///./src/cartesian/point.js","webpack:///./src/canvas/contextInterface.js","webpack:///./src/layers/base.js","webpack:///./src/sheet/constants.js","webpack:///./src/sheet/dimensions.js","webpack:///./src/sheet/position.js","webpack:///./src/sheet/utils.js","webpack:///./src/layers/sheet.js","webpack:///./src/layers/stones.js","webpack:///./src/layers/scoreboard.js","webpack:///./src/entities/team.js","webpack:///./src/sheet/relativePoint.js","webpack:///./src/cartesian/utils.js","webpack:///./src/entities/stone.js","webpack:///./src/managers/stone.js","webpack:///./src/managers/end.js","webpack:///./src/managers/collision.js","webpack:///./src/index.js","webpack:///./src/game.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Canvas","[object Object]","this","container","document","getElementById","canvas","createElement","appendChild","setCanvasSizeToWindowSize","window","addEventListener","e","width","innerWidth","height","innerHeight","twoDContext","getContext","Point","x","y","limit","min","max","contextInterface_ContextInterface","ctx","get2DContext","setup","setDefaultX","setDefaultY","clearRect","minX","maxX","minY","maxY","color","fillStyle","fillRect","fill","origin","end","thickness","strokeStyle","beginPath","moveTo","lineWidth","lineTo","stroke","radius","arc","Math","PI","endpoint","length","rect","text","font","fillText","midY","midX","base_LayerBase","undefined","super","HOG_TO_TEE","TEE_TO_BACK","HOG_TO_BACK","STONE_RADIUS","HOG_PADDING","BACK_PADDING","dimensions_SheetDimensions","foot","playAreaPixels","playAreaFeet","meter","position_SheetPosition","horizontalOffset","verticalOffset","centerPositionX","halfWidth","centerPositionY","halfLength","xValue","yValue","feetPlusOffsetY","applyOffsetY","feet","sheet_SheetLayer","originX","originY","setBackgroundColor","drawBackground","drawHouse","drawCenterLine","drawHogLine","drawTeeLine","drawBackLine","topMid","bottomMid","drawLine","hogLineY","teeLineY","backLineY","centerPoint","drawCircle","stones_StonesLayer","stoneRadius","stones","clear","stone","drawStone","position","scoreboard_ScoreBoardLayer","team1","team2","currentEnd","scoreBoardOrigin","scoreBoardEnd","drawRectangle","drawStones","team1Y","team2Y","drawText","score","hasLastStone","team","stonesRemainingThisEnd","Team","endScores","reduce","points","acc","push","relativePoint_SheetRelativePoint","absoluteX","relativeX","absoluteY","relativeY","newAbsoluteX","generateRelativeX","newAbsoluteY","generateRelativeY","distanceBetweenTwoPoints","pointA","pointB","abs","STONE_ACCELERATION","BUTTON","stone_Stone","intendedPosition","distanceInMeters","direction","velocity","sqrt","elapsedTime","isMoving","amountToMove","pixelsPerSecondToMS","movePixelsInDirection","slowDown","rotate","mps","accelleration","pixelsPerSecond","timeInMS","pixelsToMove","point","distance","percentOfDirection","constructor","pointOffsetInDirection","stoneRadiusInPx","distanceToButton","stone_StoneManager","stonesInPlay","newStonePoint","noMovingStones","filter","inBounds","EndManager","stoneManager","setupEnd","currentTeam","goesFirst","setCurrentTeam","clearStones","noTurnsRemain","completeEnd","addStone","changeTeam","scoreEnd","sontesInHouse","stonesInHouse","blankEnd","scoringStones","awardPoints","inHouse","sort","a","b","awardNoPoints","winningTeam","losingTeam","STONE_DIAMETER_IN_PX","CollisionManager","stoneA","stoneB","canCollide","collision_CollisionHandler","distanceBetweenStones","movingStone","stationaryStone","angleBetweenStones","theta","atan2","angleBetweenTwoPoints","setDistanceBetweenStones","collision","checkIfStonesAreTouching","collideStones","moveStoneForSolidImpact","setValuesForCollision","effectVelocity","effectDirection","distanceToMove","oppositeDirection","setAngleBetweenStones","collisionPercent","percentOfCollision","radians","offset","cos","game","mainLayer","sheetLayer","stonesLayer","scoreBoardLayer","teams","determineFirstPlayer","endManager","initialRender","round","random","mainRender","auxilaryRender","render","bindEvents","lastFrameTime","requestAnimationFrame","loop","bind","newPoint","pointWithinBoundaries","clientX","clientY","takeTurn","frameTime","timeSinceLastFrame","handleDroppedFrames","updateGameState","move","removeOutOfBoundsStones","collideAll","start"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class Canvas {\n  constructor(){\n    this.container = document.getElementById('canvas-container');\n    this.canvas = document.createElement('canvas')\n    this.container.appendChild(this.canvas)\n    this.setCanvasSizeToWindowSize();\n\n    window.addEventListener('resize', (e)=>{\n      this.setCanvasSizeToWindowSize();\n    });\n  }\n\n  setCanvasSizeToWindowSize(){\n    this.canvas.width = window.innerWidth\n    this.canvas.height = window.innerHeight\n  }\n\n  get2DContext(){\n    if(!this.twoDContext){\n      this.twoDContext = this.canvas.getContext(\"2d\")\n    }\n    return this.twoDContext\n  }\n\n  get width(){\n    return this.canvas.width\n  }\n\n  get height(){\n    return this.canvas.height\n  }\n}\n","export default class Point {\n  constructor(x, y){\n    this.x = x\n    this.y = y\n  }\n}\n","/* An interface for canvas's context to be used as a base layer class */\nimport Point from '../cartesian/point'\n\nfunction limit(value, min, max){\n  if(value < min){\n    return min\n  } else if (value > max){\n    return max\n  }\n  return value\n}\n\nexport default class ContextInterface {\n  constructor(canvas){\n    this.canvas = canvas\n    this.ctx = canvas.get2DContext();\n    this.setup();\n    window.addEventListener('resize', (e)=>{\n      this.setup();\n    });\n  }\n\n  setup(){\n    this.setDefaultX()\n    this.setDefaultY()\n  }\n\n  clear(){\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)\n  }\n\n  setDefaultX(){\n    this.minX = 0\n    this.maxX = this.canvas.width\n  }\n\n  setDefaultY(){\n    this.minY = 0\n    this.maxY = this.canvas.height\n  }\n\n  setBackgroundColor(color){\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(\n      this.minX, this.minY,\n      this.width, this.height\n    );\n  }\n\n  fill(color){\n    this.ctx.fillStyle = color\n    this.ctx.fill()\n  }\n\n  drawLine(origin, end, color, thickness){\n    this.ctx.strokeStyle = color\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(origin.x, origin.y);\n    this.ctx.lineWidth = thickness\n    this.ctx.lineTo(end.x, end.y);\n    this.ctx.stroke();\n  }\n\n  drawCircle(origin, radius, color){\n    this.ctx.beginPath();\n    this.ctx.arc(\n      origin.x,\n      origin.y,\n      radius, 0, Math.PI * 2\n    );\n    this.fill(color)\n  }\n\n  drawRectangle(origin, endpoint, color){\n    const length = endpoint.x - origin.x\n    const width = endpoint.y - origin.y\n    this.ctx.rect(origin.x,origin.y,length,width);\n    this.fill(color)\n  }\n\n  drawText(text, origin){\n    this.ctx.font = \"18px Arial\";\n    this.ctx.fillStyle = \"white\"\n    this.ctx.fillText(text,origin.x, origin.y);\n  }\n\n  pointWithinBoundaries(x, y){\n    x = limit(x, this.minX, this.maxX)\n    y = limit(y, this.minY, this.maxY)\n\n    return new Point(x, y)\n  }\n\n  get width(){\n    return this.maxX - this.minX\n  }\n\n  get height(){\n    return this.maxY - this.minY\n  }\n\n  get midY(){\n    return (this.minY + this.maxY) / 2\n  }\n\n  get midX(){\n    return (this.minX + this.maxX) / 2\n  }\n}\n","import ContextInterface from '../canvas/contextInterface'\nimport Canvas from '../canvas'\n\nexport default class LayerBase extends ContextInterface {\n  constructor(canvas){\n    // Optionally pass a canvas in.\n    // This can help with performance as creating lots of canvases\n    // might slow things down.\n\n    if(canvas === undefined){\n      // Generate a new canvas.\n      canvas = new Canvas()\n    }\n    super(canvas)\n  }\n}\n","// Dimensions of a curling sheet\n// Dimensions listed in feet\nexport const HOG_TO_TEE = 21\nexport const TEE_TO_BACK = 6\nexport const HOG_TO_BACK = HOG_TO_TEE + TEE_TO_BACK\nexport const SHEET_WIDTH = 14\nexport const STONE_RADIUS = 0.5\n\n// Purely Aesthetic\nexport const HOG_PADDING = 3\nexport const BACK_PADDING = 2\n","import {\n  HOG_PADDING,\n  HOG_TO_TEE,\n  TEE_TO_BACK,\n  BACK_PADDING\n} from './constants'\n\nexport default class SheetDimensions {\n  static playAreaPixels(){\n    return window.innerHeight\n  }\n\n  static playAreaFeet(){\n    return HOG_PADDING + HOG_TO_TEE + TEE_TO_BACK + BACK_PADDING\n  }\n\n  static get foot(){\n    return this.playAreaPixels() / this.playAreaFeet()\n  }\n\n  static get meter(){\n    return this.playAreaPixels() / (this.playAreaFeet() * 0.3048)\n  }\n\n  static meters(n){\n    return this.meter * n\n  }\n\n  static feet(n){\n    return this.foot * n\n  }\n\n  static width(){\n    return this.foot * 14\n  }\n\n  static halfWidth(){\n    return this.width() / 2\n  }\n\n  static length(){\n    return this.playAreaPixels()\n  }\n\n  static halfLength(){\n    return this.length() / 2\n  }\n}\n","import SheetDimensions from './dimensions'\n\nexport default class SheetPosition {\n  static verticalOffset(){\n    return 0\n  }\n\n  static horizontalOffset(){\n    return 0\n  }\n\n  static centerPositionX(){\n    return this.horizontalOffset() + (window.innerWidth / 2)\n  }\n\n  static centerPositionY(){\n    return this.verticalOffset() + (SheetDimensions.playAreaPixels() / 2)\n  }\n\n  static originX(){\n    return this.centerPositionX() - SheetDimensions.halfWidth()\n  }\n\n  static maxX(){\n    return this.centerPositionX() + SheetDimensions.halfWidth()\n  }\n\n  static originY(){\n    return this.centerPositionY() - SheetDimensions.halfLength()\n  }\n\n  static maxY(){\n    return this.centerPositionY() + SheetDimensions.halfLength()\n  }\n\n  static applyOffsetX(xValue){\n    return this.horizontalOffset() + xValue\n  }\n\n  static applyOffsetY(yValue){\n    return this.verticalOffset() + yValue\n  }\n}\n","import SheetPosition from './position'\nimport SheetDimensions from './dimensions'\n\nexport function feetPlusOffsetX(value){\n  return SheetPosition.applyOffsetX(SheetDimensions.feet(value))\n}\n\nexport function feetPlusOffsetY(value){\n  return SheetPosition.applyOffsetY(SheetDimensions.feet(value))\n}\n","import LayerBase from './base'\nimport SheetDimensions from '../sheet/dimensions'\nimport SheetPosition from '../sheet/position'\nimport {HOG_PADDING, HOG_TO_TEE, HOG_TO_BACK} from '../sheet/constants'\nimport {feetPlusOffsetY} from '../sheet/utils'\nimport Point from '../cartesian/point'\n\nexport default class SheetLayer extends LayerBase {\n  setDefaultX(){\n    this.minX = SheetPosition.originX()\n    this.maxX = SheetPosition.maxX()\n  }\n\n  setDefaultY(){\n    this.minY = SheetPosition.originY()\n    this.maxY = SheetPosition.maxY()\n  }\n\n  feet(n){\n    return SheetDimensions.feet(n)\n  }\n\n  render(){\n    this.setBackgroundColor(\"white\")\n    this.drawBackground()\n  }\n\n  drawBackground(){\n    this.drawHouse()\n    this.drawCenterLine()\n    this.drawHogLine()\n    this.drawTeeLine()\n    this.drawBackLine()\n  }\n\n  drawCenterLine(){\n    const topMid = new Point(this.midX, this.minY)\n    const bottomMid = new Point(this.midX, this.maxY)\n    this.drawLine(topMid, bottomMid, \"black\", 2)\n  }\n\n  drawHogLine(){\n    const hogLineY = feetPlusOffsetY(HOG_PADDING)\n    this.drawLine(\n      new Point(this.minX, hogLineY),\n      new Point(this.maxX, hogLineY),\n      \"black\", 5\n    )\n  }\n\n  drawTeeLine(){\n    const teeLineY = feetPlusOffsetY(HOG_PADDING + HOG_TO_TEE)\n    this.drawLine(\n      new Point(this.minX, teeLineY),\n      new Point(this.maxX, teeLineY),\n      \"black\", 2\n    )\n  }\n\n  drawBackLine(){\n\n    const backLineY = feetPlusOffsetY(HOG_PADDING + HOG_TO_BACK)\n    this.drawLine(\n      new Point(this.minX, backLineY),\n      new Point(this.maxX, backLineY),\n      \"black\", 2\n    )\n  }\n\n  drawHouse(){\n    const teeLineY = feetPlusOffsetY(HOG_PADDING + HOG_TO_TEE)\n    const centerPoint = new Point(this.midX, teeLineY)\n    this.drawCircle(\n      centerPoint,\n      this.feet(6),\n      \"blue\"\n    )\n\n    this.drawCircle(\n      centerPoint,\n      this.feet(4),\n      \"white\"\n    )\n\n    this.drawCircle(\n      centerPoint,\n      this.feet(2),\n      \"red\"\n    )\n\n    this.drawCircle(\n      centerPoint,\n      this.feet(0.75),\n      \"white\"\n    )\n  }\n}\n","import LayerBase from './base'\nimport SheetDimensions from '../sheet/dimensions'\nimport SheetPosition from '../sheet/position'\nimport {STONE_RADIUS} from '../sheet/constants'\n\nexport default class StonesLayer extends LayerBase {\n  setDefaultX(){\n    const stoneRadius = SheetDimensions.feet(STONE_RADIUS)\n    this.minX = SheetPosition.originX() - stoneRadius\n    this.maxX = SheetPosition.maxX() + stoneRadius\n  }\n\n  setDefaultY(){\n    this.minY = SheetPosition.originY()\n    this.maxY = SheetPosition.maxY()\n  }\n\n  render(stones){\n    this.clear()\n    for(let stone of stones){\n      this.drawStone(stone.position, stone.color)\n    }\n  }\n\n  drawStone(origin, color){\n    this.drawCircle(\n      origin,\n      SheetDimensions.feet(STONE_RADIUS),\n      \"grey\"\n    )\n\n    this.drawCircle(\n      origin,\n      SheetDimensions.feet(STONE_RADIUS - 0.15),\n      color\n    )\n  }\n}\n","import LayerBase from './base'\nimport Point from '../cartesian/point'\n\nexport default class ScoreBoardLayer extends LayerBase {\n  render(team1, team2, currentEnd){\n    const scoreBoardOrigin = new Point(15,15)\n    const scoreBoardEnd = new Point(260,100)\n    this.drawRectangle(scoreBoardOrigin,scoreBoardEnd,'#2e3fab')\n    const team1Y = 40\n    const team2Y = 65\n    this.drawStones(team1, team1Y - 6)\n    this.drawStones(team2, team2Y - 6)\n\n    this.drawText(`team1 - ${team1.score} ${team1.hasLastStone ? '✓' : ''}`,new Point(25,team1Y))\n    this.drawText(`team2 - ${team2.score} ${team2.hasLastStone ? '✓' : ''}`,new Point(25,team2Y))\n\n    this.drawText(`end ${currentEnd}`,new Point(25,90))\n  }\n\n  drawStones(team, y){\n    const stoneSpacing = 15\n    for (let i = 0; i < team.stonesRemainingThisEnd; i++) {\n      this.drawCircle(new Point(130 + i*stoneSpacing, y), 5, team.color)\n    }\n  }\n}\n","export default class Team {\n  constructor(color){\n    this.color = color\n    this.endScores = [] //The score per end\n    this.stonesRemainingThisEnd = 8\n    this.hasLastStone = false //determine player order\n  }\n\n  get score(){\n    return this.endScores.reduce((points, acc)=>{return points + acc},0)\n  }\n\n  awardPoints(points){\n    this.endScores.push(points)\n  }\n\n  awardNoPoints(){\n    this.endScores.push(0)\n  }\n\n  goesFirst(){\n    return !this.hasLastStone\n  }\n}\n","import SheetPosition from './position'\nimport SheetDimensions from './dimensions'\nimport Point from '../cartesian/point'\n\nexport default class SheetRelativePoint extends Point {\n  generateRelativeX(absoluteX){\n    this.relativeX = (absoluteX - SheetPosition.originX()) / SheetDimensions.width()\n  }\n\n  generateRelativeY(absoluteY){\n    this.relativeY = (absoluteY - SheetPosition.originY()) / SheetDimensions.length()\n  }\n\n  get x(){\n    return (this.relativeX * SheetDimensions.width()) + SheetPosition.originX()\n  }\n\n  get y(){\n    return (this.relativeY * SheetDimensions.length()) + SheetPosition.originY()\n  }\n\n  set x(newAbsoluteX){\n    this.generateRelativeX(newAbsoluteX)\n  }\n\n  set y(newAbsoluteY){\n    this.generateRelativeY(newAbsoluteY)\n  }\n}\n","import Point from './point'\n\nexport function angleBetweenTwoPoints(pointA,pointB){\n  let theta = Math.atan2(pointB.x - pointA.x, pointB.y - pointA.y) + (Math.PI / 2)\n  if(theta < 0){\n    theta = Math.abs(theta)\n  }\n\n  const RAD_TO_DEG = 57.2957795130823209;\n  return theta * RAD_TO_DEG\n}\n\nexport function distanceBetweenTwoPoints(pointA, pointB){\n  const differenceX = Math.abs(pointA.x - pointB.x)\n  const differenceY = Math.abs(pointA.y - pointB.y)\n  return (differenceX + differenceY)\n}\n\nexport function pointOffsetInDirection(point, distance, direction){\n  const percentOfDirection = (direction / 180) - 0.5\n  return new point.constructor(\n    point.x + (distance * percentOfDirection),\n    point.y + (distance * (1 - percentOfDirection))\n  )\n}\n","import SheetRelativePoint from '../sheet/relativePoint'\nimport SheetPosition from '../sheet/position'\nimport SheetDimensions from '../sheet/dimensions'\nimport {feetPlusOffsetY} from '../sheet/utils'\nimport {pointOffsetInDirection, distanceBetweenTwoPoints} from '../cartesian/utils'\nimport Point from '../cartesian/point'\nimport {HOG_PADDING, HOG_TO_TEE, HOG_TO_BACK, STONE_RADIUS} from '../sheet/constants'\n\n\nconst STONE_ACCELERATION = -0.15\nconst BUTTON = new Point(SheetPosition.centerPositionX(), feetPlusOffsetY(HOG_TO_TEE))\n\nfunction intendedDistanceToVelocity(distanceInMeters){\n  // A = (v_f^2 - v_i^2) / 2d\n  // But solving for 'v_i'\n  return Math.sqrt(STONE_ACCELERATION * -1 * 2 * distanceInMeters)\n}\n\n\nexport default class Stone {\n  constructor(intendedPosition, team){\n    this.intendedPosition = new SheetRelativePoint(intendedPosition.x, intendedPosition.y)\n    this.position = new SheetRelativePoint(intendedPosition.x, SheetPosition.originY())\n    this.color = team.color\n    this.team = team\n    this.direction = 90\n\n    //Pixels / Second\n    this.velocity = intendedDistanceToVelocity((this.intendedPosition.y - feetPlusOffsetY(HOG_PADDING)) / SheetDimensions.meter) * SheetDimensions.meter\n  }\n\n  isMoving(){\n    return this.velocity > 0\n  }\n\n  move(elapsedTime){\n    if(this.isMoving()){\n      const amountToMove = this.pixelsPerSecondToMS(this.velocity, elapsedTime)\n      this.movePixelsInDirection(amountToMove)\n\n      if(this.position.y > feetPlusOffsetY(HOG_PADDING)){\n        this.slowDown(elapsedTime)\n        this.rotate(elapsedTime)\n      }\n    }\n  }\n\n  slowDown(elapsedTime){\n    const mps = this.velocity / SheetDimensions.meter\n    const accelleration = this.pixelsPerSecondToMS(STONE_ACCELERATION, elapsedTime)\n    this.velocity = (mps + accelleration) * SheetDimensions.meter\n    if(this.velocity < 0){\n      this.velocity = 0\n    }\n  }\n\n  rotate(elapsedTime){ this.direction } // TODO: implement curling.\n\n  pixelsPerSecondToMS(pixelsPerSecond, timeInMS){\n    return (pixelsPerSecond / 1000) * timeInMS\n  }\n\n  movePixelsInDirection(pixelsToMove, direction = this.direction){\n    this.position = pointOffsetInDirection(this.position, pixelsToMove, direction)\n  }\n\n  inBounds(){\n    const stoneRadiusInPx = SheetDimensions.feet(STONE_RADIUS)\n\n    // After Hog\n    if(this.position.y - stoneRadiusInPx < feetPlusOffsetY(HOG_PADDING) && !this.isMoving()){\n      return false\n    }\n\n    // Before backline\n    if(this.position.y + stoneRadiusInPx > feetPlusOffsetY(HOG_PADDING + HOG_TO_BACK)){\n      return false\n    }\n\n    if(this.position.x - stoneRadiusInPx <= SheetPosition.originX()){\n      return false\n    }\n\n    if(this.position.x + stoneRadiusInPx >= SheetPosition.maxX()){\n      return false\n    }\n\n    return true\n  }\n\n  inHouse(){\n    return this.distanceToButton() + SheetDimensions.feet(STONE_RADIUS) < SheetDimensions.feet(12)\n  }\n\n  distanceToButton(){\n    return distanceBetweenTwoPoints(this.position, BUTTON)\n  }\n\n}\n","import Stone from '../entities/stone'\n\nexport default class StoneManager {\n  constructor(){\n    this.stonesInPlay = []\n  }\n\n  noMovingStones(){\n    for(let stone of this.stonesInPlay){\n      if(stone.isMoving()){\n        return false\n      }\n    }\n    return true\n  }\n\n  addStone(newStonePoint, team){\n    if(this.noMovingStones()){\n      const stone = new Stone(newStonePoint, team)\n      this.stonesInPlay.push(stone)\n    }\n  }\n\n  clearStones(){\n    this.stonesInPlay = []\n  }\n\n  removeOutOfBoundsStones(){\n    this.stonesInPlay = this.stonesInPlay.filter( stone => stone.inBounds() )\n  }\n}\n","export default class EndManager {\n  constructor(team1, team2, stoneManager){\n    this.team1 = team1\n    this.team2 = team2\n    this.stoneManager = stoneManager\n    this.currentEnd = 1\n    this.setupEnd()\n  }\n\n  setCurrentTeam(){\n    this.currentTeam = this.team1.goesFirst() ? this.team1 : this.team2\n  }\n\n  changeTeam(){\n    if(this.currentTeam == this.team1){\n      this.currentTeam = this.team2\n    } else {\n      this.currentTeam = this.team1\n    }\n  }\n\n  setupEnd(){\n    this.setCurrentTeam()\n    this.stoneManager.clearStones()\n    this.team1.stonesRemainingThisEnd = 8\n    this.team2.stonesRemainingThisEnd = 8\n  }\n\n  noTurnsRemain(){\n    return !(this.team1.stonesRemainingThisEnd + this.team2.stonesRemainingThisEnd)\n  }\n\n  takeTurn(point){\n    if(this.stoneManager.noMovingStones()){\n      if(this.noTurnsRemain()){\n        this.completeEnd()\n      }\n\n      this.stoneManager.addStone(point, this.currentTeam)\n      if(this.currentTeam === this.team1){\n        this.team1.stonesRemainingThisEnd--\n      } else {\n        this.team2.stonesRemainingThisEnd--\n      }\n\n      this.changeTeam()\n    }\n  }\n\n  completeEnd(){\n    this.scoreEnd()\n    this.setupEnd()\n    this.currentEnd++\n  }\n\n  scoreEnd(){\n    const sontesInHouse = this.stonesInHouse()\n\n    if(sontesInHouse.length === 0){\n      this.blankEnd()\n      return\n    }\n\n    let scoringStones = 1\n    while(sontesInHouse[scoringStones - 1].team === sontesInHouse[scoringStones].team){\n      scoringStones++\n    }\n\n    this.awardPoints(sontesInHouse[0].team, scoringStones)\n  }\n\n  stonesInHouse(){\n    return this.stoneManager.stonesInPlay\n      .filter((s) => s.inHouse())\n      .sort((a,b)=> a.distanceToButton() - b.distanceToButton())\n  }\n\n  blankEnd(){\n    this.team1.awardNoPoints()\n    this.team2.awardNoPoints()\n  }\n\n  awardPoints(winningTeam, points){\n    winningTeam.awardPoints(points)\n    winningTeam.hasLastStone = false\n\n    const losingTeam = winningTeam === this.team1 ? this.team2 : this.team1\n    losingTeam.awardNoPoints()\n    losingTeam.hasLastStone = true\n  }\n}\n","import SheetDimensions from '../sheet/dimensions'\nimport {STONE_RADIUS} from '../sheet/constants'\nimport {angleBetweenTwoPoints, distanceBetweenTwoPoints} from '../cartesian/utils'\n\nconst STONE_DIAMETER_IN_PX = SheetDimensions.feet(STONE_RADIUS * 2)\n\nexport default class CollisionManager {\n  static collideAll(stonesInPlay){\n    for(let stoneA of stonesInPlay){\n      if(stoneA.isMoving()){\n        for(let stoneB of stonesInPlay){\n          if(this.canCollide(stoneA, stoneB)){\n            new CollisionHandler(stoneA, stoneB)\n          }\n        }\n      }\n    }\n  }\n\n  static canCollide(stoneA, stoneB){\n    // At the moment, only collide moving stones with stationary stones.\n    // as the collision code gets more sophisticated, this shouldn't be an issue.\n    return (stoneA !== stoneB && !stoneB.isMoving())\n  }\n}\n\nclass CollisionHandler {\n  // There are a lot of issues here as I have tried to do this based off of intuition\n  // Rather than coding the physics proper.\n  // Most notibly is how velocity is handled, as there is only velocity in 1D.\n\n  setDistanceBetweenStones(){\n    this.distanceBetweenStones = distanceBetweenTwoPoints(\n      this.movingStone.position,\n      this.stationaryStone.position\n    )\n  }\n\n  setAngleBetweenStones(){\n    this.angleBetweenStones = angleBetweenTwoPoints(\n      this.movingStone.position,\n      this.stationaryStone.position\n    )\n  }\n\n  constructor(movingStone, stationaryStone){\n    this.movingStone = movingStone\n    this.stationaryStone = stationaryStone\n    this.setDistanceBetweenStones()\n\n    this.collision = this.checkIfStonesAreTouching()\n\n    if(this.collision){\n      this.collideStones()\n    }\n  }\n\n  checkIfStonesAreTouching(){\n    return this.distanceBetweenStones <= STONE_DIAMETER_IN_PX\n  }\n\n  collideStones(){\n    this.moveStoneForSolidImpact()\n\n    this.setValuesForCollision()\n    this.effectVelocity()\n    this.effectDirection()\n  }\n\n  moveStoneForSolidImpact(){\n    if(this.distanceBetweenStones < STONE_DIAMETER_IN_PX){\n      const distanceToMove = STONE_DIAMETER_IN_PX - this.distanceBetweenStones\n      const oppositeDirection = (this.movingStone.direction - 180) * -1\n\n      this.movingStone.movePixelsInDirection(distanceToMove, oppositeDirection)\n    }\n  }\n\n  setValuesForCollision(){\n    this.setDistanceBetweenStones()\n    this.setAngleBetweenStones()\n  }\n\n  effectVelocity(){\n    const collisionPercent = this.percentOfCollision()\n    this.stationaryStone.velocity = this.movingStone.velocity * (1 - collisionPercent)\n    this.movingStone.velocity = this.movingStone.velocity * collisionPercent\n  }\n\n  percentOfCollision(){\n    const angle = ((this.angleBetweenStones - 90 + this.movingStone.direction))\n    const radians = angle / 180 * Math.PI\n    const offset = Math.cos(radians) * this.distanceBetweenStones\n\n    return Math.abs(offset) / STONE_DIAMETER_IN_PX\n  }\n\n  effectDirection(){\n    this.stationaryStone.direction = this.angleBetweenStones\n    this.movingStone.direction = 180 - this.angleBetweenStones\n  }\n}\n","import Game from './game'\n\nconst game = new Game();\ngame.setup()\ngame.start()\n","import Canvas from './canvas'\nimport LayerBase from './layers/base'\nimport SheetLayer from './layers/sheet'\nimport StonesLayer from './layers/stones'\nimport ScoreBoardLayer from './layers/scoreboard'\nimport Team from './entities/team'\nimport StoneManager from './managers/stone'\nimport EndManager from './managers/end'\nimport CollisionManager from './managers/collision'\n\nexport default class Game {\n  setup(){\n    this.canvas = new Canvas()\n    this.mainLayer = new LayerBase(this.canvas)\n    this.sheetLayer = new SheetLayer(this.canvas)\n    this.stonesLayer = new StonesLayer()\n    this.scoreBoardLayer = new ScoreBoardLayer()\n\n    const team1 = new Team(\"darkred\")\n    const team2 = new Team(\"yellow\")\n\n    this.teams = [team1, team2]\n\n    this.determineFirstPlayer()\n\n    this.stoneManager = new StoneManager()\n    this.endManager = new EndManager(team1, team2, this.stoneManager)\n\n    this.initialRender();\n  }\n\n  determineFirstPlayer(){\n    this.teams[Math.round(Math.random())].hasLastStone = true\n  }\n\n  initialRender(){\n    this.mainRender()\n    this.auxilaryRender()\n  }\n\n  auxilaryRender(){\n    // Layers that don't need to be rendered 60 times a second\n    // such as UI components and static backgrounds.\n    this.mainLayer.setBackgroundColor(\"#222641\")\n    this.sheetLayer.render()\n  }\n\n  mainRender(){\n    this.stonesLayer.render(this.stoneManager.stonesInPlay)\n    this.scoreBoardLayer.render(this.teams[0], this.teams[1], this.endManager.currentEnd)\n  }\n\n  start(){\n    this.bindEvents()\n    this.lastFrameTime = 0\n    window.requestAnimationFrame(this.loop.bind(this))\n  }\n\n  bindEvents(){\n    document.addEventListener('click', (e)=>{\n      const newPoint = this.stonesLayer.pointWithinBoundaries(e.clientX, e.clientY)\n      this.endManager.takeTurn(newPoint)\n    })\n\n    window.addEventListener('resize', (e)=>{\n      this.auxilaryRender();\n      this.mainRender()\n    })\n  }\n\n  loop(frameTime){\n    const timeSinceLastFrame = this.handleDroppedFrames(frameTime - this.lastFrameTime)\n    this.updateGameState(timeSinceLastFrame)\n    this.mainRender()\n\n    this.lastFrameTime = frameTime\n    window.requestAnimationFrame(this.loop.bind(this))\n  }\n\n  updateGameState(timeSinceLastFrame){\n    for(let stone of this.stoneManager.stonesInPlay){\n      stone.move(timeSinceLastFrame)\n      this.stoneManager.removeOutOfBoundsStones()\n      CollisionManager.collideAll(this.stoneManager.stonesInPlay)\n    }\n  }\n\n  handleDroppedFrames(timeSinceLastFrame){\n    const defaultFrameLength = 15\n    return timeSinceLastFrame < 1000 ? timeSinceLastFrame : defaultFrameLength\n  }\n}\n"],"sourceRoot":""}