{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/canvas/index.js","webpack:///./src/cartesian/point.js","webpack:///./src/canvas/contextInterface.js","webpack:///./src/layers/base.js","webpack:///./src/sheet/constants.js","webpack:///./src/sheet/dimensions.js","webpack:///./src/sheet/position.js","webpack:///./src/sheet/utils.js","webpack:///./src/layers/sheet.js","webpack:///./src/layers/stones.js","webpack:///./src/layers/scoreboard.js","webpack:///./src/entities/team.js","webpack:///./src/sheet/relativePoint.js","webpack:///./src/cartesian/utils.js","webpack:///./src/entities/stone.js","webpack:///./src/managers/stone.js","webpack:///./src/managers/end.js","webpack:///./src/managers/collision.js","webpack:///./src/index.js","webpack:///./src/game.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Canvas","[object Object]","this","container","document","getElementById","canvas","createElement","appendChild","setCanvasSizeToWindowSize","window","addEventListener","e","width","innerWidth","height","innerHeight","twoDContext","getContext","Point","x","y","limit","min","max","contextInterface_ContextInterface","ctx","get2DContext","setup","setDefaultX","setDefaultY","clearRect","minX","maxX","minY","maxY","color","fillStyle","fillRect","fill","origin","end","thickness","strokeStyle","beginPath","moveTo","lineWidth","lineTo","stroke","radius","arc","Math","PI","endpoint","length","rect","text","font","fillText","midY","midX","base_LayerBase","undefined","super","HOG_TO_TEE","TEE_TO_BACK","HOG_TO_BACK","STONE_RADIUS","HOG_PADDING","BACK_PADDING","dimensions_SheetDimensions","foot","playAreaPixels","playAreaFeet","meter","position_SheetPosition","horizontalOffset","verticalOffset","centerPositionX","halfWidth","centerPositionY","halfLength","xValue","yValue","feetPlusOffsetY","applyOffsetY","feet","sheet_SheetLayer","originX","originY","setBackgroundColor","drawBackground","drawHouse","drawCenterLine","drawHogLine","drawTeeLine","drawBackLine","topMid","bottomMid","drawLine","hogLineY","teeLineY","backLineY","centerPoint","drawCircle","stones_StonesLayer","stoneRadius","stones","clear","stone","drawStone","position","scoreboard_ScoreBoardLayer","team1","team2","currentEnd","scoreBoardOrigin","scoreBoardEnd","drawRectangle","drawStones","team1Y","team2Y","drawText","score","hasLastStone","drawHammer","team","stonesRemainingThisEnd","Team","endScores","reduce","points","acc","push","relativePoint_SheetRelativePoint","absoluteX","console","log","relativeX","absoluteY","relativeY","newAbsoluteX","generateRelativeX","newAbsoluteY","generateRelativeY","distanceBetweenTwoPoints","pointA","pointB","abs","STONE_ACCELERATION","BUTTON","stone_Stone","intendedPosition","distanceInMeters","direction","velocity","sqrt","elapsedTime","isMoving","amountToMove","pixelsPerSecondToMS","movePixelsInDirection","slowDown","rotate","mps","accelleration","pixelsPerSecond","timeInMS","pixelsToMove","point","distance","percentOfDirection","constructor","pointOffsetInDirection","stoneRadiusInPx","distanceToButton","stone_StoneManager","stonesInPlay","newStonePoint","noMovingStones","filter","inBounds","EndManager","stoneManager","setupEnd","currentTeam","goesFirst","setCurrentTeam","clearStones","noTurnsRemain","completeEnd","addStone","changeTeam","scoreEnd","sontesInHouse","stonesInHouse","blankEnd","scoringStones","awardPoints","inHouse","sort","a","b","awardNoPoints","winningTeam","losingTeam","STONE_DIAMETER_IN_PX","CollisionManager","stoneA","stoneB","canCollide","collision_CollisionHandler","distanceBetweenStones","movingStone","stationaryStone","angleBetweenStones","theta","atan2","angleBetweenTwoPoints","setDistanceBetweenStones","collision","checkIfStonesAreTouching","collideStones","moveStoneForSolidImpact","setValuesForCollision","effectVelocity","effectDirection","distanceToMove","oppositeDirection","setAngleBetweenStones","collisionPercent","percentOfCollision","radians","offset","cos","game","mainLayer","sheetLayer","stonesLayer","scoreBoardLayer","teams","determineFirstPlayer","endManager","initialRender","round","random","mainRender","auxilaryRender","render","bindEvents","lastFrameTime","requestAnimationFrame","loop","bind","newPoint","pointWithinBoundaries","clientX","clientY","takeTurn","frameTime","timeSinceLastFrame","handleDroppedFrames","updateGameState","move","removeOutOfBoundsStones","collideAll","start"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class Canvas {\n  constructor(){\n    this.container = document.getElementById('canvas-container');\n    this.canvas = document.createElement('canvas')\n    this.container.appendChild(this.canvas)\n    this.setCanvasSizeToWindowSize();\n\n    window.addEventListener('resize', (e)=>{\n      this.setCanvasSizeToWindowSize();\n    });\n  }\n\n  setCanvasSizeToWindowSize(){\n    this.canvas.width = window.innerWidth\n    this.canvas.height = window.innerHeight\n  }\n\n  get2DContext(){\n    if(!this.twoDContext){\n      this.twoDContext = this.canvas.getContext(\"2d\")\n    }\n    return this.twoDContext\n  }\n\n  get width(){\n    return this.canvas.width\n  }\n\n  get height(){\n    return this.canvas.height\n  }\n}\n","export default class Point {\n  constructor(x, y){\n    this.x = x\n    this.y = y\n  }\n}\n","/* An interface for canvas's context to be used as a base layer class */\nimport Point from '../cartesian/point'\n\nfunction limit(value, min, max){\n  if(value < min){\n    return min\n  } else if (value > max){\n    return max\n  }\n  return value\n}\n\nexport default class ContextInterface {\n  constructor(canvas){\n    this.canvas = canvas\n    this.ctx = canvas.get2DContext();\n    this.setup();\n    window.addEventListener('resize', (e)=>{\n      this.setup();\n    });\n  }\n\n  setup(){\n    this.setDefaultX()\n    this.setDefaultY()\n  }\n\n  clear(){\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)\n  }\n\n  setDefaultX(){\n    this.minX = 0\n    this.maxX = this.canvas.width\n  }\n\n  setDefaultY(){\n    this.minY = 0\n    this.maxY = this.canvas.height\n  }\n\n  setBackgroundColor(color){\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(\n      this.minX, this.minY,\n      this.width, this.height\n    );\n  }\n\n  fill(color){\n    this.ctx.fillStyle = color\n    this.ctx.fill()\n  }\n\n  drawLine(origin, end, color, thickness){\n    this.ctx.strokeStyle = color\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(origin.x, origin.y);\n    this.ctx.lineWidth = thickness\n    this.ctx.lineTo(end.x, end.y);\n    this.ctx.stroke();\n  }\n\n  drawCircle(origin, radius, color){\n    this.ctx.beginPath();\n    this.ctx.arc(\n      origin.x,\n      origin.y,\n      radius, 0, Math.PI * 2\n    );\n    this.fill(color)\n  }\n\n  drawRectangle(origin, endpoint, color){\n    const length = endpoint.x - origin.x\n    const width = endpoint.y - origin.y\n    this.ctx.rect(origin.x,origin.y,length,width);\n    this.fill(color)\n  }\n\n  drawText(text, origin){\n    this.ctx.font = \"18px Arial\";\n    this.ctx.fillStyle = \"white\"\n    this.ctx.fillText(text,origin.x, origin.y);\n  }\n\n  pointWithinBoundaries(x, y){\n    x = limit(x, this.minX, this.maxX)\n    y = limit(y, this.minY, this.maxY)\n\n    return new Point(x, y)\n  }\n\n  get width(){\n    return this.maxX - this.minX\n  }\n\n  get height(){\n    return this.maxY - this.minY\n  }\n\n  get midY(){\n    return (this.minY + this.maxY) / 2\n  }\n\n  get midX(){\n    return (this.minX + this.maxX) / 2\n  }\n}\n","import ContextInterface from '../canvas/contextInterface'\nimport Canvas from '../canvas'\n\nexport default class LayerBase extends ContextInterface {\n  constructor(canvas){\n    // Optionally pass a canvas in.\n    // This can help with performance as creating lots of canvases\n    // might slow things down.\n\n    if(canvas === undefined){\n      // Generate a new canvas.\n      canvas = new Canvas()\n    }\n    super(canvas)\n  }\n}\n","// Dimensions of a curling sheet\n// Dimensions listed in feet\nexport const HOG_TO_TEE = 21\nexport const TEE_TO_BACK = 6\nexport const HOG_TO_BACK = HOG_TO_TEE + TEE_TO_BACK\nexport const SHEET_WIDTH = 14\nexport const STONE_RADIUS = 0.5\n\n// Purely Aesthetic\nexport const HOG_PADDING = 3\nexport const BACK_PADDING = 2\n","import {\n  HOG_PADDING,\n  HOG_TO_TEE,\n  TEE_TO_BACK,\n  BACK_PADDING\n} from './constants'\n\nexport default class SheetDimensions {\n  static playAreaPixels(){\n    return window.innerHeight\n  }\n\n  static playAreaFeet(){\n    return HOG_PADDING + HOG_TO_TEE + TEE_TO_BACK + BACK_PADDING\n  }\n\n  static get foot(){\n    return this.playAreaPixels() / this.playAreaFeet()\n  }\n\n  static get meter(){\n    return this.playAreaPixels() / (this.playAreaFeet() * 0.3048)\n  }\n\n  static meters(n){\n    return this.meter * n\n  }\n\n  static feet(n){\n    return this.foot * n\n  }\n\n  static width(){\n    return this.foot * 14\n  }\n\n  static halfWidth(){\n    return this.width() / 2\n  }\n\n  static length(){\n    return this.playAreaPixels()\n  }\n\n  static halfLength(){\n    return this.length() / 2\n  }\n}\n","import SheetDimensions from './dimensions'\n\nexport default class SheetPosition {\n  static verticalOffset(){\n    return 0\n  }\n\n  static horizontalOffset(){\n    return 0\n  }\n\n  static centerPositionX(){\n    return this.horizontalOffset() + (window.innerWidth / 2)\n  }\n\n  static centerPositionY(){\n    return this.verticalOffset() + (SheetDimensions.playAreaPixels() / 2)\n  }\n\n  static originX(){\n    return this.centerPositionX() - SheetDimensions.halfWidth()\n  }\n\n  static maxX(){\n    return this.centerPositionX() + SheetDimensions.halfWidth()\n  }\n\n  static originY(){\n    return this.centerPositionY() - SheetDimensions.halfLength()\n  }\n\n  static maxY(){\n    return this.centerPositionY() + SheetDimensions.halfLength()\n  }\n\n  static applyOffsetX(xValue){\n    return this.horizontalOffset() + xValue\n  }\n\n  static applyOffsetY(yValue){\n    return this.verticalOffset() + yValue\n  }\n}\n","import SheetPosition from './position'\nimport SheetDimensions from './dimensions'\n\nexport function feetPlusOffsetX(value){\n  return SheetPosition.applyOffsetX(SheetDimensions.feet(value))\n}\n\nexport function feetPlusOffsetY(value){\n  return SheetPosition.applyOffsetY(SheetDimensions.feet(value))\n}\n","import LayerBase from './base'\nimport SheetDimensions from '../sheet/dimensions'\nimport SheetPosition from '../sheet/position'\nimport {HOG_PADDING, HOG_TO_TEE, HOG_TO_BACK} from '../sheet/constants'\nimport {feetPlusOffsetY} from '../sheet/utils'\nimport Point from '../cartesian/point'\n\nexport default class SheetLayer extends LayerBase {\n  setDefaultX(){\n    this.minX = SheetPosition.originX()\n    this.maxX = SheetPosition.maxX()\n  }\n\n  setDefaultY(){\n    this.minY = SheetPosition.originY()\n    this.maxY = SheetPosition.maxY()\n  }\n\n  feet(n){\n    return SheetDimensions.feet(n)\n  }\n\n  render(){\n    this.setBackgroundColor(\"white\")\n    this.drawBackground()\n  }\n\n  drawBackground(){\n    this.drawHouse()\n    this.drawCenterLine()\n    this.drawHogLine()\n    this.drawTeeLine()\n    this.drawBackLine()\n  }\n\n  drawCenterLine(){\n    const topMid = new Point(this.midX, this.minY)\n    const bottomMid = new Point(this.midX, this.maxY)\n    this.drawLine(topMid, bottomMid, \"black\", 2)\n  }\n\n  drawHogLine(){\n    const hogLineY = feetPlusOffsetY(HOG_PADDING)\n    this.drawLine(\n      new Point(this.minX, hogLineY),\n      new Point(this.maxX, hogLineY),\n      \"black\", 5\n    )\n  }\n\n  drawTeeLine(){\n    const teeLineY = feetPlusOffsetY(HOG_PADDING + HOG_TO_TEE)\n    this.drawLine(\n      new Point(this.minX, teeLineY),\n      new Point(this.maxX, teeLineY),\n      \"black\", 2\n    )\n  }\n\n  drawBackLine(){\n\n    const backLineY = feetPlusOffsetY(HOG_PADDING + HOG_TO_BACK)\n    this.drawLine(\n      new Point(this.minX, backLineY),\n      new Point(this.maxX, backLineY),\n      \"black\", 2\n    )\n  }\n\n  drawHouse(){\n    const teeLineY = feetPlusOffsetY(HOG_PADDING + HOG_TO_TEE)\n    const centerPoint = new Point(this.midX, teeLineY)\n    this.drawCircle(\n      centerPoint,\n      this.feet(6),\n      \"blue\"\n    )\n\n    this.drawCircle(\n      centerPoint,\n      this.feet(4),\n      \"white\"\n    )\n\n    this.drawCircle(\n      centerPoint,\n      this.feet(2),\n      \"red\"\n    )\n\n    this.drawCircle(\n      centerPoint,\n      this.feet(0.75),\n      \"white\"\n    )\n  }\n}\n","import LayerBase from './base'\nimport SheetDimensions from '../sheet/dimensions'\nimport SheetPosition from '../sheet/position'\nimport {STONE_RADIUS} from '../sheet/constants'\n\nexport default class StonesLayer extends LayerBase {\n  setDefaultX(){\n    const stoneRadius = SheetDimensions.feet(STONE_RADIUS)\n    this.minX = SheetPosition.originX() - stoneRadius\n    this.maxX = SheetPosition.maxX() + stoneRadius\n  }\n\n  setDefaultY(){\n    this.minY = SheetPosition.originY()\n    this.maxY = SheetPosition.maxY()\n  }\n\n  render(stones){\n    this.clear()\n    for(let stone of stones){\n      this.drawStone(stone.position, stone.color)\n    }\n  }\n\n  drawStone(origin, color){\n    this.drawCircle(\n      origin,\n      SheetDimensions.feet(STONE_RADIUS),\n      \"grey\"\n    )\n\n    this.drawCircle(\n      origin,\n      SheetDimensions.feet(STONE_RADIUS - 0.15),\n      color\n    )\n  }\n}\n","import LayerBase from './base'\nimport Point from '../cartesian/point'\n\nexport default class ScoreBoardLayer extends LayerBase {\n  render(team1, team2, currentEnd){\n    const scoreBoardOrigin = new Point(15,15)\n    const scoreBoardEnd = new Point(260,100)\n    this.drawRectangle(scoreBoardOrigin,scoreBoardEnd,'#2e3fab')\n    const team1Y = 40\n    const team2Y = 65\n    this.drawStones(team1, team1Y - 6)\n    this.drawStones(team2, team2Y - 6)\n    this.drawText(`team1 - ${team1.score}`,new Point(25,team1Y))\n    this.drawText(`team2 - ${team2.score}`,new Point(25,team2Y))\n\n    this.drawText(`end ${currentEnd}`,new Point(25,90))\n\n    if(team1.hasLastStone){\n      this.drawHammer(108, team1Y)\n    } else {\n      this.drawHammer(108, team2Y)\n    }\n  }\n\n  drawStones(team, y){\n    const stoneSpacing = 15\n    for (let i = 0; i < team.stonesRemainingThisEnd; i++) {\n      this.drawCircle(new Point(130 + i*stoneSpacing, y), 5, team.color)\n    }\n  }\n\n  drawHammer(x, y){\n    const origin = new Point(x, y)\n    const end = new Point(x + 5, y + 10)\n    this.drawText('✓',origin)\n  }\n}\n","export default class Team {\n  constructor(color){\n    this.color = color\n    this.endScores = [] //The score per end\n    this.stonesRemainingThisEnd = 8\n    this.hasLastStone = false //determine player order\n  }\n\n  get score(){\n    return this.endScores.reduce((points, acc)=>{return points + acc},0)\n  }\n\n  awardPoints(points){\n    this.endScores.push(points)\n  }\n\n  awardNoPoints(){\n    this.endScores.push(0)\n  }\n\n  goesFirst(){\n    return !this.hasLastStone\n  }\n}\n","import SheetPosition from './position'\nimport SheetDimensions from './dimensions'\nimport Point from '../cartesian/point'\n\nexport default class SheetRelativePoint extends Point {\n  generateRelativeX(absoluteX){\n    console.log(absoluteX)\n    this.relativeX = (absoluteX - SheetPosition.originX()) / SheetDimensions.width()\n  }\n\n  generateRelativeY(absoluteY){\n    this.relativeY = (absoluteY - SheetPosition.originY()) / SheetDimensions.length()\n  }\n\n  get x(){\n    return (this.relativeX * SheetDimensions.width()) + SheetPosition.originX()\n  }\n\n  get y(){\n    return (this.relativeY * SheetDimensions.length()) + SheetPosition.originY()\n  }\n\n  set x(newAbsoluteX){\n    this.generateRelativeX(newAbsoluteX)\n  }\n\n  set y(newAbsoluteY){\n    this.generateRelativeY(newAbsoluteY)\n  }\n}\n","import Point from './point'\n\nexport function angleBetweenTwoPoints(pointA,pointB){\n  let theta = Math.atan2(pointB.x - pointA.x, pointB.y - pointA.y) + (Math.PI / 2)\n  if(theta < 0){\n    theta = Math.abs(theta)\n  }\n\n  const RAD_TO_DEG = 57.2957795130823209;\n  return theta * RAD_TO_DEG\n}\n\nexport function distanceBetweenTwoPoints(pointA, pointB){\n  const differenceX = Math.abs(pointA.x - pointB.x)\n  const differenceY = Math.abs(pointA.y - pointB.y)\n  return (differenceX + differenceY)\n}\n\nexport function pointOffsetInDirection(point, distance, direction){\n  const percentOfDirection = (direction / 180) - 0.5\n  return new point.constructor(\n    point.x + (distance * percentOfDirection),\n    point.y + (distance * (1 - percentOfDirection))\n  )\n}\n","import SheetRelativePoint from '../sheet/relativePoint'\nimport SheetPosition from '../sheet/position'\nimport SheetDimensions from '../sheet/dimensions'\nimport {feetPlusOffsetY} from '../sheet/utils'\nimport {pointOffsetInDirection, distanceBetweenTwoPoints} from '../cartesian/utils'\nimport Point from '../cartesian/point'\nimport {HOG_PADDING, HOG_TO_TEE, HOG_TO_BACK, STONE_RADIUS} from '../sheet/constants'\n\n\nconst STONE_ACCELERATION = -0.15\nconst BUTTON = new Point(SheetPosition.centerPositionX(), feetPlusOffsetY(HOG_TO_TEE))\n\nfunction intendedDistanceToVelocity(distanceInMeters){\n  // A = (v_f^2 - v_i^2) / 2d\n  // But solving for 'v_i'\n  return Math.sqrt(STONE_ACCELERATION * -1 * 2 * distanceInMeters)\n}\n\n\nexport default class Stone {\n  constructor(intendedPosition, team){\n    this.intendedPosition = new SheetRelativePoint(intendedPosition.x, intendedPosition.y)\n    this.position = new SheetRelativePoint(intendedPosition.x, SheetPosition.originY())\n    this.color = team.color\n    this.team = team\n    this.direction = 90\n\n    //Pixels / Second\n    this.velocity = intendedDistanceToVelocity((this.intendedPosition.y - feetPlusOffsetY(HOG_PADDING)) / SheetDimensions.meter) * SheetDimensions.meter\n  }\n\n  isMoving(){\n    return this.velocity > 0\n  }\n\n  move(elapsedTime){\n    if(this.isMoving()){\n      const amountToMove = this.pixelsPerSecondToMS(this.velocity, elapsedTime)\n      this.movePixelsInDirection(amountToMove)\n\n      if(this.position.y > feetPlusOffsetY(HOG_PADDING)){\n        this.slowDown(elapsedTime)\n        this.rotate(elapsedTime)\n      }\n    }\n  }\n\n  slowDown(elapsedTime){\n    const mps = this.velocity / SheetDimensions.meter\n    const accelleration = this.pixelsPerSecondToMS(STONE_ACCELERATION, elapsedTime)\n    this.velocity = (mps + accelleration) * SheetDimensions.meter\n    if(this.velocity < 0){\n      this.velocity = 0\n    }\n  }\n\n  rotate(elapsedTime){ this.direction } // TODO: implement curling.\n\n  pixelsPerSecondToMS(pixelsPerSecond, timeInMS){\n    return (pixelsPerSecond / 1000) * timeInMS\n  }\n\n  movePixelsInDirection(pixelsToMove, direction = this.direction){\n    this.position = pointOffsetInDirection(this.position, pixelsToMove, direction)\n  }\n\n  inBounds(){\n    const stoneRadiusInPx = SheetDimensions.feet(STONE_RADIUS)\n\n    // After Hog\n    if(this.position.y - stoneRadiusInPx < feetPlusOffsetY(HOG_PADDING) && !this.isMoving()){\n      return false\n    }\n\n    // Before backline\n    if(this.position.y + stoneRadiusInPx > feetPlusOffsetY(HOG_PADDING + HOG_TO_BACK)){\n      return false\n    }\n\n    if(this.position.x - stoneRadiusInPx <= SheetPosition.originX()){\n      return false\n    }\n\n    if(this.position.x + stoneRadiusInPx >= SheetPosition.maxX()){\n      return false\n    }\n\n    return true\n  }\n\n  inHouse(){\n    return this.distanceToButton() + SheetDimensions.feet(STONE_RADIUS) < SheetDimensions.feet(12)\n  }\n\n  distanceToButton(){\n    return distanceBetweenTwoPoints(this.position, BUTTON)\n  }\n\n}\n","import Stone from '../entities/stone'\n\nexport default class StoneManager {\n  constructor(){\n    this.stonesInPlay = []\n  }\n\n  noMovingStones(){\n    for(let stone of this.stonesInPlay){\n      if(stone.isMoving()){\n        return false\n      }\n    }\n    return true\n  }\n\n  addStone(newStonePoint, team){\n    if(this.noMovingStones()){\n      const stone = new Stone(newStonePoint, team)\n      this.stonesInPlay.push(stone)\n    }\n  }\n\n  clearStones(){\n    this.stonesInPlay = []\n  }\n\n  removeOutOfBoundsStones(){\n    this.stonesInPlay = this.stonesInPlay.filter( stone => stone.inBounds() )\n  }\n}\n","export default class EndManager {\n  constructor(team1, team2, stoneManager){\n    this.team1 = team1\n    this.team2 = team2\n    this.stoneManager = stoneManager\n    this.currentEnd = 1\n    this.setupEnd()\n  }\n\n  setCurrentTeam(){\n    this.currentTeam = this.team1.goesFirst() ? this.team1 : this.team2\n  }\n\n  changeTeam(){\n    if(this.currentTeam == this.team1){\n      this.currentTeam = this.team2\n    } else {\n      this.currentTeam = this.team1\n    }\n  }\n\n  setupEnd(){\n    this.setCurrentTeam()\n    this.stoneManager.clearStones()\n    this.team1.stonesRemainingThisEnd = 8\n    this.team2.stonesRemainingThisEnd = 8\n  }\n\n  noTurnsRemain(){\n    return !(this.team1.stonesRemainingThisEnd + this.team2.stonesRemainingThisEnd)\n  }\n\n  takeTurn(point){\n    if(this.stoneManager.noMovingStones()){\n      if(this.noTurnsRemain()){\n        this.completeEnd()\n      }\n\n      this.stoneManager.addStone(point, this.currentTeam)\n      if(this.currentTeam === this.team1){\n        this.team1.stonesRemainingThisEnd--\n      } else {\n        this.team2.stonesRemainingThisEnd--\n      }\n\n      this.changeTeam()\n    }\n  }\n\n  completeEnd(){\n    this.scoreEnd()\n    this.setupEnd()\n    this.currentEnd++\n  }\n\n  scoreEnd(){\n    const sontesInHouse = this.stonesInHouse()\n\n    if(sontesInHouse.length === 0){\n      this.blankEnd()\n      return\n    }\n\n    let scoringStones = 1\n    while(sontesInHouse[scoringStones - 1].team === sontesInHouse[scoringStones].team){\n      scoringStones++\n    }\n\n    this.awardPoints(sontesInHouse[0].team, scoringStones)\n  }\n\n  stonesInHouse(){\n    return this.stoneManager.stonesInPlay\n      .filter((s) => s.inHouse())\n      .sort((a,b)=> a.distanceToButton() - b.distanceToButton())\n  }\n\n  blankEnd(){\n    this.team1.awardNoPoints()\n    this.team2.awardNoPoints()\n  }\n\n  awardPoints(winningTeam, points){\n    winningTeam.awardPoints(points)\n    winningTeam.hasLastStone = false\n\n    const losingTeam = winningTeam === this.team1 ? this.team2 : this.team1\n    losingTeam.awardNoPoints()\n    losingTeam.hasLastStone = true\n  }\n}\n","import SheetDimensions from '../sheet/dimensions'\nimport {STONE_RADIUS} from '../sheet/constants'\nimport {angleBetweenTwoPoints, distanceBetweenTwoPoints} from '../cartesian/utils'\n\nconst STONE_DIAMETER_IN_PX = SheetDimensions.feet(STONE_RADIUS * 2)\n\nexport default class CollisionManager {\n  static collideAll(stonesInPlay){\n    for(let stoneA of stonesInPlay){\n      if(stoneA.isMoving()){\n        for(let stoneB of stonesInPlay){\n          if(this.canCollide(stoneA, stoneB)){\n            new CollisionHandler(stoneA, stoneB)\n          }\n        }\n      }\n    }\n  }\n\n  static canCollide(stoneA, stoneB){\n    // At the moment, only collide moving stones with stationary stones.\n    // as the collision code gets more sophisticated, this shouldn't be an issue.\n    return (stoneA !== stoneB && !stoneB.isMoving())\n  }\n}\n\nclass CollisionHandler {\n  // There are a lot of issues here as I have tried to do this based off of intuition\n  // Rather than coding the physics proper.\n  // Most notibly is how velocity is handled, as there is only velocity in 1D.\n\n  setDistanceBetweenStones(){\n    this.distanceBetweenStones = distanceBetweenTwoPoints(\n      this.movingStone.position,\n      this.stationaryStone.position\n    )\n  }\n\n  setAngleBetweenStones(){\n    this.angleBetweenStones = angleBetweenTwoPoints(\n      this.movingStone.position,\n      this.stationaryStone.position\n    )\n  }\n\n  constructor(movingStone, stationaryStone){\n    this.movingStone = movingStone\n    this.stationaryStone = stationaryStone\n    this.setDistanceBetweenStones()\n\n    this.collision = this.checkIfStonesAreTouching()\n\n    if(this.collision){\n      this.collideStones()\n    }\n  }\n\n  checkIfStonesAreTouching(){\n    return this.distanceBetweenStones <= STONE_DIAMETER_IN_PX\n  }\n\n  collideStones(){\n    this.moveStoneForSolidImpact()\n\n    this.setValuesForCollision()\n    this.effectVelocity()\n    this.effectDirection()\n  }\n\n  moveStoneForSolidImpact(){\n    if(this.distanceBetweenStones < STONE_DIAMETER_IN_PX){\n      const distanceToMove = STONE_DIAMETER_IN_PX - this.distanceBetweenStones\n      const oppositeDirection = (this.movingStone.direction - 180) * -1\n\n      this.movingStone.movePixelsInDirection(distanceToMove, oppositeDirection)\n    }\n  }\n\n  setValuesForCollision(){\n    this.setDistanceBetweenStones()\n    this.setAngleBetweenStones()\n  }\n\n  effectVelocity(){\n    const collisionPercent = this.percentOfCollision()\n    this.stationaryStone.velocity = this.movingStone.velocity * (1 - collisionPercent)\n    this.movingStone.velocity = this.movingStone.velocity * collisionPercent\n  }\n\n  percentOfCollision(){\n    const angle = ((this.angleBetweenStones - 90 + this.movingStone.direction))\n    const radians = angle / 180 * Math.PI\n    const offset = Math.cos(radians) * this.distanceBetweenStones\n\n    return Math.abs(offset) / STONE_DIAMETER_IN_PX\n  }\n\n  effectDirection(){\n    this.stationaryStone.direction = this.angleBetweenStones\n    this.movingStone.direction = 180 - this.angleBetweenStones\n  }\n}\n","import Game from './game'\n\nconst game = new Game();\ngame.setup()\ngame.start()\n","import Canvas from './canvas'\nimport LayerBase from './layers/base'\nimport SheetLayer from './layers/sheet'\nimport StonesLayer from './layers/stones'\nimport ScoreBoardLayer from './layers/scoreboard'\nimport Team from './entities/team'\nimport StoneManager from './managers/stone'\nimport EndManager from './managers/end'\nimport CollisionManager from './managers/collision'\n\nexport default class Game {\n  setup(){\n    this.canvas = new Canvas()\n    this.mainLayer = new LayerBase(this.canvas)\n    this.sheetLayer = new SheetLayer(this.canvas)\n    this.stonesLayer = new StonesLayer()\n    this.scoreBoardLayer = new ScoreBoardLayer()\n\n    const team1 = new Team(\"darkred\")\n    const team2 = new Team(\"yellow\")\n\n    this.teams = [team1, team2]\n\n    this.determineFirstPlayer()\n\n    this.stoneManager = new StoneManager()\n    this.endManager = new EndManager(team1, team2, this.stoneManager)\n\n    this.initialRender();\n  }\n\n  determineFirstPlayer(){\n    this.teams[Math.round(Math.random())].hasLastStone = true\n  }\n\n  initialRender(){\n    this.mainRender()\n    this.auxilaryRender()\n  }\n\n  auxilaryRender(){\n    // Layers that don't need to be rendered 60 times a second\n    // such as UI components and static backgrounds.\n    this.mainLayer.setBackgroundColor(\"#222641\")\n    this.sheetLayer.render()\n  }\n\n  mainRender(){\n    this.stonesLayer.render(this.stoneManager.stonesInPlay)\n    this.scoreBoardLayer.render(this.teams[0], this.teams[1], this.endManager.currentEnd)\n  }\n\n  start(){\n    this.bindEvents()\n    this.lastFrameTime = 0\n    window.requestAnimationFrame(this.loop.bind(this))\n  }\n\n  bindEvents(){\n    document.addEventListener('click', (e)=>{\n      const newPoint = this.stonesLayer.pointWithinBoundaries(e.clientX, e.clientY)\n      this.endManager.takeTurn(newPoint)\n    })\n\n    window.addEventListener('resize', (e)=>{\n      this.auxilaryRender();\n      this.mainRender()\n    })\n  }\n\n  loop(frameTime){\n    const timeSinceLastFrame = this.handleDroppedFrames(frameTime - this.lastFrameTime)\n    this.updateGameState(timeSinceLastFrame)\n    this.mainRender()\n\n    this.lastFrameTime = frameTime\n    window.requestAnimationFrame(this.loop.bind(this))\n  }\n\n  updateGameState(timeSinceLastFrame){\n    for(let stone of this.stoneManager.stonesInPlay){\n      stone.move(timeSinceLastFrame)\n      this.stoneManager.removeOutOfBoundsStones()\n      CollisionManager.collideAll(this.stoneManager.stonesInPlay)\n    }\n  }\n\n  handleDroppedFrames(timeSinceLastFrame){\n    const defaultFrameLength = 15\n    return timeSinceLastFrame < 1000 ? timeSinceLastFrame : defaultFrameLength\n  }\n}\n"],"sourceRoot":""}